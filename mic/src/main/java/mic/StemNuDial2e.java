package mic;

import VASSAL.build.GameModule;
import VASSAL.build.module.Chatter;
import VASSAL.build.module.documentation.HelpFile;
import VASSAL.command.ChangeTracker;
import VASSAL.command.Command;
import VASSAL.command.CommandEncoder;
import VASSAL.configure.HotKeyConfigurer;
import VASSAL.counters.*;
import com.google.common.base.Joiner;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.swing.*;
import java.awt.*;
import java.awt.event.KeyEvent;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

import static mic.Util.deserializeBase64Obj;
import static mic.Util.logToChat;
import static mic.Util.serializeToBase64;

/**
 * Created by Mic on 04/12/2018.
 *
 * this file is for all programmatic reactions to ',', '.' and 'ctrl-r' commands issued to this new style of dial
 * New style of dial:
 *
 * 1) looks like the open face 2nd edition dial instead of the 1st edition
 * 2) no more additional graphics due to the masked/hidden side - a simple eye-with-slash icon will be used to indicate the hidden mode of the dial (icon at center)
 * 3) when in reveal mode, the selected move (at the top) will be copied, larger, in the center and rotations can't be done at all
 * 4) when in hidden mode, dial rotation commands will only tweak the rotation of the faceplate for the owner of the dial, not for any other player
 * 5) The pilot name in text (white text over black background) above the dial; the ship name in text (same colors) under the dial, no more icon gfx to manage
 * 6) a player can't cheat anymore by swapping mask gfx by a transparent empty png
 * 7) the open face dial has to be kept in OTA2 - no mistakes are allowed because patches can't happen, unless a download all is forced in the content checker
 * 8) File name should be: D2e_'ship name from contracted manifest file names'.jpg
 * 9) Dial graphics should be generated by Mike's tool when he has time to implement it, otherwise generated by me in an outside program or from dialgen + photoshop
 * 10) new dial graphics added when a ship graphic is added in the best case scenario as info pours in from previews.
 */

public class StemNuDial2e extends Decorator implements EditablePiece, Serializable {
    public static final String ID = "StemNuDial2e";


    final public static Map<String, KeyStroke> moveCodeToKeyStroke = ImmutableMap.<String, KeyStroke>builder()
            .put("1F", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("2F", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("3F", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("4F", KeyStroke.getKeyStroke(KeyEvent.VK_4, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("5F", KeyStroke.getKeyStroke(KeyEvent.VK_5, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("1T", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.CTRL_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("2T", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.CTRL_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("3T", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.CTRL_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("1Y", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.ALT_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("2Y", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.ALT_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("3Y", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.ALT_DOWN_MASK+KeyEvent.SHIFT_DOWN_MASK, false))
            .put("1B", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.CTRL_DOWN_MASK, false))
            .put("2B", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.CTRL_DOWN_MASK, false))
            .put("3B", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.CTRL_DOWN_MASK, false))
            .put("1N", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.ALT_DOWN_MASK, false))
            .put("2N", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.ALT_DOWN_MASK, false))
            .put("3N", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.ALT_DOWN_MASK, false))
            .put("1K", KeyStroke.getKeyStroke(KeyEvent.VK_1, KeyEvent.CTRL_DOWN_MASK+KeyEvent.ALT_DOWN_MASK, false))
            .put("2K", KeyStroke.getKeyStroke(KeyEvent.VK_2, KeyEvent.CTRL_DOWN_MASK+KeyEvent.ALT_DOWN_MASK, false))
            .put("3K", KeyStroke.getKeyStroke(KeyEvent.VK_3, KeyEvent.CTRL_DOWN_MASK+KeyEvent.ALT_DOWN_MASK, false))
            .put("4K", KeyStroke.getKeyStroke(KeyEvent.VK_4, KeyEvent.CTRL_DOWN_MASK+KeyEvent.ALT_DOWN_MASK, false))
            .put("5K", KeyStroke.getKeyStroke(KeyEvent.VK_5, KeyEvent.CTRL_DOWN_MASK+KeyEvent.ALT_DOWN_MASK, false))
            .put("1A", KeyStroke.getKeyStroke(KeyEvent.VK_6, KeyEvent.CTRL_DOWN_MASK, false))
            .put("1S", KeyStroke.getKeyStroke(KeyEvent.VK_6, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("2S", KeyStroke.getKeyStroke(KeyEvent.VK_7, KeyEvent.SHIFT_DOWN_MASK, false))
            .put("1D", KeyStroke.getKeyStroke(KeyEvent.VK_6, KeyEvent.ALT_DOWN_MASK, false))
            .put("1L", KeyStroke.getKeyStroke(KeyEvent.VK_Q, KeyEvent.CTRL_DOWN_MASK, false))
            .put("2L", KeyStroke.getKeyStroke(KeyEvent.VK_W, KeyEvent.CTRL_DOWN_MASK, false))
            .put("3L", KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.CTRL_DOWN_MASK, false))
            .put("1P", KeyStroke.getKeyStroke(KeyEvent.VK_Q, KeyEvent.ALT_DOWN_MASK, false))
            .put("2P", KeyStroke.getKeyStroke(KeyEvent.VK_W, KeyEvent.ALT_DOWN_MASK, false))
            .put("3P", KeyStroke.getKeyStroke(KeyEvent.VK_E, KeyEvent.ALT_DOWN_MASK, false))
            .put("1E", KeyStroke.getKeyStroke(KeyEvent.VK_I, KeyEvent.CTRL_DOWN_MASK, false))
            .put("2E", KeyStroke.getKeyStroke(KeyEvent.VK_Y, KeyEvent.CTRL_DOWN_MASK, false))
            .put("3E", KeyStroke.getKeyStroke(KeyEvent.VK_T, KeyEvent.CTRL_DOWN_MASK, false))
            .put("1R", KeyStroke.getKeyStroke(KeyEvent.VK_I, KeyEvent.ALT_DOWN_MASK, false))
            .put("2R", KeyStroke.getKeyStroke(KeyEvent.VK_Y, KeyEvent.ALT_DOWN_MASK, false))
            .put("3R", KeyStroke.getKeyStroke(KeyEvent.VK_T, KeyEvent.ALT_DOWN_MASK, false))
            .build();

    public StemNuDial2e()  {
        this(null);
    }

    public StemNuDial2e(GamePiece piece)
    {
        setInner(piece);

    }

    @Override
    public void mySetState(String newState) {

    }
    /*
    @Override
    public String getState(){

    }
    */

    @Override
    public String myGetState() {
        Integer isHiddenPropCheck = Integer.parseInt(piece.getProperty("isHidden").toString());
        int ownerSide = getOwnerOfThisDial();
        int thisSide = Util.getCurrentPlayer().getSide();

        //sync source is the dial owner, must not pass the owner's vision of a hidden dial
        if(thisSide != ownerSide && isHiddenPropCheck == 1){
            Embellishment chosenMoveEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Chosen Move");
            Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Chosen Speed");
            Embellishment sideHideEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Side Hide");
            Embellishment centralHideEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Central Hide");
            chosenMoveEmb.setValue(0);
            chosenSpeedEmb.setValue(0);
            sideHideEmb.setValue(0);
            centralHideEmb.setValue(1);
        }

        //sync source is not the dial owner, must pass the owner's vision of a hidden dial
        if(thisSide == ownerSide && isHiddenPropCheck == 1){
            Embellishment chosenMoveEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Chosen Move");
            Embellishment chosenSpeedEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Chosen Speed");
            Embellishment sideHideEmb = (Embellishment)Util.getEmbellishment(piece,"Layer - Side Hide");
            Embellishment centralHideEmb = (Embellishment)Util.getEmbellishment(piece, "Layer - Central Hide");
            chosenMoveEmb.setValue(1);

            String moveSpeedLayerString = getLayerFromScratch(0);
            chosenSpeedEmb.setValue(Integer.parseInt(moveSpeedLayerString)); //use the right speed layer

            sideHideEmb.setValue(1);
            centralHideEmb.setValue(0);
        }
        return "";
    }
    @Override
    public String myGetType() {
        return ID;
    }
    @Override
    protected KeyCommand[] myGetKeyCommands() {
        return new KeyCommand[0];
    }

    @Override
    public Command myKeyEvent(KeyStroke stroke) { return null; }


    public String buildStateString(int moveModification){
        /*
         * dialString, like: 1BW,1FB,1NW,2TW,2BB,2FB,2NB,2YW,3LR,3TW,3BW,3FW,3NW,3YW,3PR,4FR
         * values, like: [1BW,1FB,1NW,2TW,2BB,2FB,2NB,2YW,3LR,3TW,3BW,3FW,3NW,3YW,3PR,4FR]
         * nbOfMoves, like: 15
         *
         * saveMoveString, like: "4" (out of 15)
         * savedMoveStringInt, like: 4
         *
         * access the move in values by using savedMoveStringInt - 1
         * newMove, like: "1TR"
         * newRawSpeed, like 1
         * newMoveSpeed, like 3 (layer 0 = empty, layer 1 = '0', layer 2 = '1', layer 6 = '5')
         * moveWithoutSpeed, like: "TR"
         * moveImage, like: "1TR.png"
         *
         * stateString, like: "emb2...." which is fed moveImage, moveName
         * moveName, like: "Hard Left 1"
         */

        // Fetch the string of movement from the dynamic property and chop it up in an array
        String dialString = piece.getProperty("dialstring").toString();
        String[] values = dialString.split(",");
        int nbOfMoves = values.length;

        // Fetch the saved move from the dynamic property of the dial piece
        String savedMoveString = piece.getProperty("selectedMove").toString();
        int savedMoveStringInt = Integer.parseInt(savedMoveString);

        if(moveModification == 1){ //if you want to shift the selected move 1 up.
            if(savedMoveStringInt == nbOfMoves) savedMoveStringInt = 1; //loop
            else savedMoveStringInt++;
        } else if(moveModification == -1) //if you want to shift the selected move 1 down
        {
            if (savedMoveStringInt == 1) savedMoveStringInt = nbOfMoves; //loop
            else savedMoveStringInt--;
        }

        String moveCode = values[savedMoveStringInt-1];
        int rawSpeed = getRawSpeedFromMoveCode(moveCode);

        //attempt to seed the move layer with the right image just like at spawn time
        StringBuilder stateString = new StringBuilder();
        StringBuilder moveNamesString = new StringBuilder();
        stateString.append("emb2;Activate;2;;;2;;;2;;;;1;false;0;-24;,");

        String moveImage;
        String moveWithoutSpeed = getMoveCodeWithoutSpeed(moveCode);
        String moveName = StemDial2e.maneuverNames.get(getMoveRaw(moveCode));
        moveNamesString.append(moveName).append(" ").append(rawSpeed);

        moveImage = StemDial2e.dialHeadingImages.get(moveWithoutSpeed);
        stateString.append(moveImage);
        // add in move names
        stateString.append(";empty,"+moveNamesString);
        stateString.append(";false;Chosen Move;;;false;;1;1;true;65,130");

        return stateString.toString();
    }

    @Override
    public Command keyEvent(KeyStroke stroke) {
        boolean hasSomethingHappened = false;
        Integer isHiddenPropCheck;

        isHiddenPropCheck = Integer.parseInt(piece.getProperty("isHidden").toString());

        //Util.logToChat("STEP 0 - keyEvent=" + stroke.getKeyEventType() + " isHidden=" + isHiddenPropCheck);
        KeyStroke checkForMassActionMapWipe = KeyStroke.getKeyStroke(KeyEvent.VK_A, KeyEvent.CTRL_DOWN_MASK + KeyEvent.SHIFT_DOWN_MASK + KeyEvent.ALT_DOWN_MASK, false);

        if (getOwnerOfThisDial() == Util.getCurrentPlayer().getSide()) {
            KeyStroke checkForCtrlRReleased = KeyStroke.getKeyStroke(KeyEvent.VK_R, KeyEvent.CTRL_DOWN_MASK, false);
            KeyStroke checkForCommaReleased = KeyStroke.getKeyStroke(KeyEvent.VK_COMMA, 0, false);
            KeyStroke checkForPeriodReleased = KeyStroke.getKeyStroke(KeyEvent.VK_PERIOD, 0, false);
            KeyStroke checkForSuperCtrlRReleased = KeyStroke.getKeyStroke(KeyEvent.VK_S, KeyEvent.CTRL_DOWN_MASK, false);
            KeyStroke checkForC = KeyStroke.getKeyStroke(KeyEvent.VK_C, 0, false);



            boolean goingLeft = checkForCommaReleased.equals(stroke);
            boolean goingRight = checkForPeriodReleased.equals(stroke);

            if(checkForCtrlRReleased.equals(stroke) || checkForSuperCtrlRReleased.equals(stroke)) { //CTRL-R or CTRL-S detected

                if(isHiddenPropCheck == 1) { // about to reveal the dial
                    //Construct the next build string
                    StringBuilder stateString = new StringBuilder();
                    stateString.append(buildStateString(0));

                    //get the speed layer to show
                    String moveSpeedLayerString = getLayerFromScratch(0);

                    DialRevealCommand revealNow = new DialRevealCommand(piece, stateString.toString(), moveSpeedLayerString, Util.getCurrentPlayer().getName(), true);
                    Command result =revealNow;

                    if(checkForSuperCtrlRReleased.equals(stroke)) { //Deal with ship movement with CTRL-S
                        String shipID = this.piece.getProperty("shipID").toString(); //gets the random UUID from the dial that was saved during spawning
                        Collection<GamePiece> pieces = GameModule.getGameModule().getGameState().getAllPieces();
                        Collection<GamePiece> piecesCopied = new ArrayList<GamePiece>(pieces);
                        for (GamePiece pieceScanned : piecesCopied) {
                            try{
                                String micID = pieceScanned.getProperty("micID").toString();

                                if (micID.equals(shipID) && pieceScanned.getMap().getMapName().equals("Contested Sector") && this.piece.getMap().getMapName().equals("Contested Sector")){
                                    String moveFromScratch = getNewMoveCodeFromScratch(0);
                                    String moveRaw = moveFromScratch.substring(0,2);
                                    KeyStroke thisKey = moveCodeToKeyStroke.get(moveRaw);
                                    if(thisKey!=null) {
                                        Command moveShipCommand = pieceScanned.keyEvent(thisKey);
                                        result.append(moveShipCommand);
                                    }
                                }
                            }catch (Exception e){
                                continue;
                            }
                        }
                    }
                    result.execute();
                    return result;
                } else if(isHiddenPropCheck == 0){ // about to hide the dial
                    //command shown to all players
                    DialHideCommand hideNow = new DialHideCommand(piece, true);
                    Command result = hideNow;

                    result.execute();
                    return result;
                }
            }
            else if(checkForC.equals(stroke)){ //collision resolution pass-through via the dial
                String shipID = this.piece.getProperty("shipID").toString(); //gets the random UUID from the dial that was saved during spawning
                Collection<GamePiece> pieces = GameModule.getGameModule().getGameState().getAllPieces();
                Collection<GamePiece> piecesCopied = new ArrayList<GamePiece>(pieces);
                for (final GamePiece pieceScanned : piecesCopied) {
                    try{
                        String micID = pieceScanned.getProperty("micID").toString();

                        // logToChat("StemNuDial2e line 270 -ship=" +pieceScanned.getProperty("micID").toString());
                        if (micID.equals(shipID) && pieceScanned.getMap().getMapName().equals("Contested Sector") && this.piece.getMap().getMapName().equals("Contested Sector")){
                            Command doCCommand = pieceScanned.keyEvent(checkForC);
                            doCCommand.execute();
                            GameModule.getGameModule().sendAndLog(doCCommand);

                        }
                    }catch (Exception e){
                        continue;
                    }
                }
            }
            else if(goingLeft || goingRight){ //rotate left, move-- or rotate right, move++

                //Util.logToChat("STEP 2b - , or . released");
                int moveMod = 0;
                if(goingLeft) moveMod = -1;
                if(goingRight) moveMod = 1;

                Command warningCommand = new Chatter.DisplayText(GameModule.getGameModule().getChatter(),"* DIAL WARNING - " + Util.getCurrentPlayer().getName() + " has rotated the " + piece.getProperty("Craft ID #").toString()
                        + " (" + piece.getProperty("Pilot Name").toString() + ") on the map. Please use your player window to do so instead.");

                if(isHiddenPropCheck == 1){ //encode only the modified selected move property
                    DialRotateCommand drc = new DialRotateCommand(piece, moveMod==1?true:false, false,  true);
                    Command result = drc;

                    if(piece.getMap().equals(VASSAL.build.module.Map.getMapById("Map0"))) result.append(warningCommand);
                    result.execute();
                    return result;
                } else if(isHiddenPropCheck == 0) { //dial is revealed, show everything to all
                    DialRotateCommand drc = new DialRotateCommand(piece, moveMod==1?true:false, true, true);
                    Command result = drc;

                    if(piece.getMap().equals(VASSAL.build.module.Map.getMapById("Map0"))) result.append(warningCommand);
                    result.execute();
                    return result;
                }
            }
        } else if(!stroke.equals(checkForMassActionMapWipe)) { // get scolded for not owning the dial that was manipulated, unless it's a mass action wipe on the map
            Util.logToChatWithoutUndo("You (player " + Util.getCurrentPlayer().getSide() + ") are not the owner of this dial, player " + getOwnerOfThisDial() + " is.");
        }
        return piece.keyEvent(stroke);
    }

    private String getNewMoveCodeFromScratch(int moveMod) {
        String dialString = piece.getProperty("dialstring").toString();
        String[] values = dialString.split(",");
        int nbOfMoves = values.length;

        // Fetch the saved move from the dynamic property of the dial piece
        String savedMoveString = piece.getProperty("selectedMove").toString();
        int savedMoveStringInt = Integer.parseInt(savedMoveString);

        if(moveMod == 1){ //if you want to shift the selected move 1 up.
            if(savedMoveStringInt == nbOfMoves) savedMoveStringInt = 1; //loop
            else savedMoveStringInt++;
        } else if(moveMod == -1) //if you want to shift the selected move 1 down
        {
            if (savedMoveStringInt == 1) savedMoveStringInt = nbOfMoves; //loop
            else savedMoveStringInt--;
        }

        if(moveMod == 1){ //if you want to shift the selected move 1 up.
            if(savedMoveStringInt == nbOfMoves) savedMoveStringInt = 1; //loop
            else savedMoveStringInt++;
        } else if(moveMod == -1) //if you want to shift the selected move 1 down
        {
            if (savedMoveStringInt == 1) savedMoveStringInt = nbOfMoves; //loop
            else savedMoveStringInt--;
        }

        String moveCode = values[savedMoveStringInt-1];

        return moveCode;
    }


    public int getRawSpeedFromMoveCode(String code){
        return Integer.parseInt(code.substring(0,1));
    }
    public int getLayerFromMoveCode(String code){
        return Integer.parseInt(code.substring(0,1)) + 1;
    }
    public String getLayerFromScratch(int moveModification){
        String dialString = piece.getProperty("dialstring").toString();
        String[] values = dialString.split(",");
        int nbOfMoves = values.length;

        // Fetch the saved move from the dynamic property of the dial piece
        String savedMoveString = piece.getProperty("selectedMove").toString();
        int savedMoveStringInt = Integer.parseInt(savedMoveString);

        if(moveModification == 1){ //if you want to shift the selected move 1 up.
            if(savedMoveStringInt == nbOfMoves) savedMoveStringInt = 1; //loop
            else savedMoveStringInt++;
        } else if(moveModification == -1) //if you want to shift the selected move 1 down
        {
            if (savedMoveStringInt == 1) savedMoveStringInt = nbOfMoves; //loop
            else savedMoveStringInt--;
        }

        String moveCode = values[savedMoveStringInt-1];
        Integer moveSpeedLayerToUse = getLayerFromMoveCode(moveCode);
        String moveSpeedLayerString = moveSpeedLayerToUse.toString();

        return moveSpeedLayerString;
    }

    public String getMoveCodeWithoutSpeed(String code){
        return code.substring(1,3);
    }

    public String getMoveRaw(String code){
        return code.substring(1,2);
    }

    public int getOwnerOfThisDial(){
        GamePiece dialPiece = (GamePiece)this.piece;
        String ownerStr = dialPiece.getProperty("owner").toString();
        int ownerInt = Integer.parseInt(ownerStr);
        return ownerInt;
    }
    public String getDescription() {
        return "Custom StemNuDial (mic.StemNuDial2e)";
    }

    public void mySetType(String type) {

    }

    public HelpFile getHelpFile() {
        return null;
    }

    public void draw(Graphics g, int x, int y, Component obs, double zoom) {
        this.piece.draw(g, x, y, obs, zoom);
    }

    public Rectangle boundingBox() {
        return this.piece.boundingBox();
    }

    public Shape getShape() {
        return this.piece.getShape();
    }

    public String getName() {
        return this.piece.getName();
    }
}